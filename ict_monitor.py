#!/usr/bin/env python3
"""
üìä ICT SILVER BULLET - PERFORMANCE MONITOR
Monitoring en temps r√©el des performances de la strat√©gie
"""

import time
import logging
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import pandas as pd

class ICTPerformanceMonitor:
    def __init__(self):
        self.start_time = datetime.now()
        self.trades_log = []
        self.daily_stats = {}
        self.performance_targets = {
            'min_daily_trades': 1,
            'target_win_rate': 50.0,
            'target_profit_factor': 2.0,
            'max_daily_drawdown': -50.0,  # ‚Ç¨
            'target_daily_profit': 20.0   # ‚Ç¨
        }
        
        # Configuration des logs
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('ict_monitor.log'),
                logging.StreamHandler()
            ]
        )
        
        logging.info("üìä ICT Performance Monitor initialis√©")
    
    def load_trades_from_log(self, log_file: str = 'ultimate_bot.log') -> List[Dict]:
        """Charger les trades depuis les logs"""
        trades = []
        
        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    # Rechercher les lignes d'entr√©e ICT
                    if 'ICT SILVER BULLET ENTRY' in line:
                        # Parser les informations de trade
                        try:
                            parts = line.split()
                            timestamp = ' '.join(parts[:2])
                            entry_type = 'SELL' if 'SELL' in line else 'BUY'
                            
                            # Extraire le prix (format variable)
                            price = None
                            for part in parts:
                                if '@' in part:
                                    price_str = part.replace('@', '').replace(',', '')
                                    try:
                                        price = float(price_str)
                                        break
                                    except:
                                        continue
                            
                            if price:
                                trades.append({
                                    'timestamp': timestamp,
                                    'type': entry_type,
                                    'entry_price': price,
                                    'status': 'OPEN'
                                })
                        except Exception as e:
                            logging.warning(f"Erreur parsing ligne trade: {e}")
                    
                    # Rechercher les lignes de sortie
                    elif 'EXIT:' in line and ('TP' in line or 'SL' in line):
                        try:
                            parts = line.split()
                            exit_reason = 'TP' if 'TP' in line else 'SL'
                            
                            # Extraire le profit
                            profit = None
                            for part in parts:
                                if '‚Ç¨' in part:
                                    profit_str = part.replace('‚Ç¨', '').replace('+', '').replace('=', '')
                                    try:
                                        profit = float(profit_str)
                                        break
                                    except:
                                        continue
                            
                            # Mettre √† jour le dernier trade ouvert
                            for trade in reversed(trades):
                                if trade.get('status') == 'OPEN':
                                    trade['status'] = 'CLOSED'
                                    trade['exit_reason'] = exit_reason
                                    trade['profit'] = profit
                                    break
                        except Exception as e:
                            logging.warning(f"Erreur parsing ligne exit: {e}")
                            
        except FileNotFoundError:
            logging.warning(f"Fichier de log {log_file} non trouv√©")
        except Exception as e:
            logging.error(f"Erreur lecture logs: {e}")
        
        return trades
    
    def calculate_daily_stats(self, trades: List[Dict]) -> Dict:
        """Calculer les statistiques quotidiennes"""
        today = datetime.now().date()
        today_trades = []
        
        for trade in trades:
            try:
                trade_date = datetime.strptime(trade['timestamp'].split()[0], '%Y-%m-%d').date()
                if trade_date == today:
                    today_trades.append(trade)
            except:
                continue
        
        if not today_trades:
            return {
                'date': today.strftime('%Y-%m-%d'),
                'total_trades': 0,
                'open_trades': 0,
                'closed_trades': 0,
                'win_rate': 0.0,
                'profit_factor': 0.0,
                'net_profit': 0.0,
                'gross_profit': 0.0,
                'gross_loss': 0.0
            }
        
        closed_trades = [t for t in today_trades if t.get('status') == 'CLOSED']
        open_trades = [t for t in today_trades if t.get('status') == 'OPEN']
        
        # Calculs statistiques
        winning_trades = [t for t in closed_trades if t.get('profit', 0) > 0]
        losing_trades = [t for t in closed_trades if t.get('profit', 0) < 0]
        
        win_rate = (len(winning_trades) / len(closed_trades) * 100) if closed_trades else 0.0
        gross_profit = sum(t.get('profit', 0) for t in winning_trades)
        gross_loss = abs(sum(t.get('profit', 0) for t in losing_trades))
        net_profit = gross_profit - gross_loss
        profit_factor = (gross_profit / gross_loss) if gross_loss > 0 else float('inf') if gross_profit > 0 else 0.0
        
        return {
            'date': today.strftime('%Y-%m-%d'),
            'total_trades': len(today_trades),
            'open_trades': len(open_trades),
            'closed_trades': len(closed_trades),
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'net_profit': net_profit,
            'gross_profit': gross_profit,
            'gross_loss': gross_loss
        }
    
    def generate_performance_report(self, stats: Dict) -> str:
        """G√©n√©rer un rapport de performance"""
        targets = self.performance_targets
        
        # Status indicators
        trades_status = "‚úÖ" if stats['total_trades'] >= targets['min_daily_trades'] else "‚ö†Ô∏è"
        wr_status = "‚úÖ" if stats['win_rate'] >= targets['target_win_rate'] else "‚ùå"
        pf_status = "‚úÖ" if stats['profit_factor'] >= targets['target_profit_factor'] else "‚ùå"
        profit_status = "‚úÖ" if stats['net_profit'] >= targets['target_daily_profit'] else "‚ö†Ô∏è"
        
        if stats['net_profit'] <= targets['max_daily_drawdown']:
            profit_status = "üö®"
        
        report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                üèÖ ICT SILVER BULLET - RAPPORT QUOTIDIEN üèÖ        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Date: {stats['date']}                                         ‚ïë
‚ïë                                                                  ‚ïë
‚ïë üìä TRADES AUJOURD'HUI:                                          ‚ïë
‚ïë   Total Trades: {stats['total_trades']:>2} {trades_status}                                  ‚ïë
‚ïë   Trades Ferm√©s: {stats['closed_trades']:>2}                                   ‚ïë
‚ïë   Trades Ouverts: {stats['open_trades']:>2}                                  ‚ïë
‚ïë                                                                  ‚ïë
‚ïë üéØ PERFORMANCE:                                                 ‚ïë
‚ïë   Win Rate: {stats['win_rate']:>6.1f}% {wr_status}                            ‚ïë
‚ïë   Profit Factor: {stats['profit_factor']:>6.2f} {pf_status}                          ‚ïë
‚ïë   Net Profit: {stats['net_profit']:>+8.2f}‚Ç¨ {profit_status}                       ‚ïë
‚ïë                                                                  ‚ïë
‚ïë üí∞ D√âTAILS:                                                     ‚ïë
‚ïë   Profits Bruts: {stats['gross_profit']:>+7.2f}‚Ç¨                          ‚ïë
‚ïë   Pertes Brutes: {stats['gross_loss']:>+7.2f}‚Ç¨                           ‚ïë
‚ïë                                                                  ‚ïë
‚ïë üéØ OBJECTIFS QUOTIDIENS:                                       ‚ïë
‚ïë   Min Trades: {targets['min_daily_trades']} | Win Rate: {targets['target_win_rate']:.0f}% | PF: {targets['target_profit_factor']:.1f} | Profit: {targets['target_daily_profit']:.0f}‚Ç¨ ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """
        
        return report.strip()
    
    def check_alerts(self, stats: Dict) -> List[str]:
        """V√©rifier les alertes de performance"""
        alerts = []
        targets = self.performance_targets
        
        if stats['net_profit'] <= targets['max_daily_drawdown']:
            alerts.append(f"üö® ALERTE DRAWDOWN: {stats['net_profit']:.2f}‚Ç¨ (limite: {targets['max_daily_drawdown']:.0f}‚Ç¨)")
        
        if stats['closed_trades'] >= 3 and stats['win_rate'] < 30:
            alerts.append(f"‚ö†Ô∏è ALERTE WIN RATE FAIBLE: {stats['win_rate']:.1f}% sur {stats['closed_trades']} trades")
        
        if stats['closed_trades'] >= 2 and stats['profit_factor'] < 1.0:
            alerts.append(f"‚ö†Ô∏è ALERTE PROFIT FACTOR: {stats['profit_factor']:.2f} < 1.0")
        
        if stats['total_trades'] == 0 and datetime.now().hour >= 16:
            alerts.append("‚ÑπÔ∏è INFO: Aucun trade aujourd'hui (apr√®s 16h)")
        
        return alerts
    
    def save_daily_report(self, stats: Dict, report: str):
        """Sauvegarder le rapport quotidien"""
        try:
            filename = f"reports/daily_report_{stats['date']}.txt"
            
            # Cr√©er le dossier s'il n'existe pas
            import os
            os.makedirs('reports', exist_ok=True)
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report)
                f.write(f"\n\nüïê G√©n√©r√© le: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            logging.info(f"üìÑ Rapport sauvegard√©: {filename}")
            
            # Sauvegarder aussi en JSON pour l'historique
            json_filename = f"reports/daily_stats_{stats['date']}.json"
            with open(json_filename, 'w') as f:
                json.dump(stats, f, indent=2)
                
        except Exception as e:
            logging.error(f"‚ùå Erreur sauvegarde rapport: {e}")
    
    def monitor_loop(self):
        """Boucle de monitoring principal"""
        logging.info("üöÄ D√©marrage du monitoring ICT Silver Bullet")
        
        last_report_hour = -1
        
        try:
            while True:
                current_hour = datetime.now().hour
                
                # Charger les trades depuis les logs
                trades = self.load_trades_from_log()
                
                # Calculer les stats quotidiennes
                daily_stats = self.calculate_daily_stats(trades)
                
                # G√©n√©rer le rapport (chaque heure ou √† la demande)
                if current_hour != last_report_hour or current_hour in [9, 12, 15, 18, 21]:
                    report = self.generate_performance_report(daily_stats)
                    print(report)
                    
                    # V√©rifier les alertes
                    alerts = self.check_alerts(daily_stats)
                    for alert in alerts:
                        logging.warning(alert)
                        print(f"\n{alert}")
                    
                    # Sauvegarder le rapport
                    self.save_daily_report(daily_stats, report)
                    
                    last_report_hour = current_hour
                
                # Monitoring continu l√©ger
                if daily_stats['open_trades'] > 0:
                    logging.info(f"üìä {daily_stats['open_trades']} position(s) ouverte(s)")
                
                # Attendre 5 minutes avant le prochain check
                time.sleep(300)
                
        except KeyboardInterrupt:
            logging.info("üõë Arr√™t du monitoring demand√©")
        except Exception as e:
            logging.error(f"‚ùå Erreur monitoring: {e}")

def main():
    """Fonction principale"""
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë            üìä ICT SILVER BULLET PERFORMANCE MONITOR üìä           ‚ïë
    ‚ïë                                                                  ‚ïë
    ‚ïë  Monitoring en temps r√©el des performances de la strat√©gie       ‚ïë
    ‚ïë  - Rapport quotidien automatique                                 ‚ïë
    ‚ïë  - Alertes de performance                                        ‚ïë  
    ‚ïë  - Sauvegarde historique                                         ‚ïë
    ‚ïë                                                                  ‚ïë
    ‚ïë  Ctrl+C pour arr√™ter                                             ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    monitor = ICTPerformanceMonitor()
    monitor.monitor_loop()

if __name__ == "__main__":
    main()
